# Feature Development Crew Tasks Configuration

plan_task:
  description: >
    Decompose the following task into ordered user stories for autonomous execution.

    TASK:
    {{task}}

    Instructions:
    1. Explore the codebase to understand the stack, conventions, and patterns
    2. Break the task into small user stories (max 20)
    3. Order by dependency: schema/DB first, backend, frontend, integration
    4. Each story must fit in one developer session (one context window)
    5. Every acceptance criterion must be mechanically verifiable
    6. Always include "Typecheck passes" as the last criterion in every story
    7. Every story MUST include test criteria — "Tests for [feature] pass"
    8. The developer is expected to write tests as part of each story

    Reply with:
    STATUS: done
    REPO: /path/to/repo
    BRANCH: feature-branch-name
    STORIES_JSON: [ ... array of story objects ... ]
  expected_output: >
    A list of ordered user stories with acceptance criteria, each fitting in one session
  agent: planner

setup_task:
  description: >
    Prepare the development environment for this feature.

    TASK:
    {{task}}

    REPO: {{repo}}
    BRANCH: {{branch}}

    Instructions:
    1. cd into the repo
    2. Create the feature branch (git checkout -b {{branch}})
    3. Read package.json, CI config, test config to understand the build/test setup
    4. Ensure .gitignore exists — if missing, create one appropriate for the detected stack (must include .env, node_modules/, *.key, *.pem at minimum)
    5. Run the build to establish a baseline
    6. Run the tests to establish a baseline
    7. Report what you found

    Reply with:
    STATUS: done
    BUILD_CMD: <build command>
    TEST_CMD: <test command>
    CI_NOTES: <brief CI notes>
    BASELINE: <baseline status>
  expected_output: >
    Environment setup confirmation with build and test commands, and baseline status
  agent: setup

implement_task:
  description: >
    Implement the following user story (simplified - one story only).

    TASK (overall):
    {{task}}

    REPO: {{repo}}
    BRANCH: {{branch}}
    BUILD_CMD: {{build_cmd}}
    TEST_CMD: {{test_cmd}}

    CURRENT STORY:
    {{current_story}}

    COMPLETED STORIES:
    {{completed_stories}}

    Instructions:
    1. Read progress log to understand codebase patterns
    2. Pull latest on the branch
    3. Implement this story only
    4. Write tests for this story's functionality
    5. Run typecheck / build
    6. Run tests to confirm they pass
    7. Commit: feat: {{current_story_id}} - {{current_story_title}}
    8. Update progress log with codebase patterns found

    Reply with:
    STATUS: done
    CHANGES: what you implemented
    TESTS: what tests you wrote
  expected_output: >
    Implemented story with details on changes and tests added
  agent: developer

verify_task:
  description: >
    Verify the developer's work on this story.

    TASK (overall):
    {{task}}

    REPO: {{repo}}
    BRANCH: {{branch}}
    CHANGES: {{changes}}
    TEST_CMD: {{test_cmd}}

    CURRENT STORY:
    {{current_story}}

    Check:
    1. Code exists (not just TODOs or placeholders)
    2. Each acceptance criterion for the story is met
    3. Tests were written for this story's functionality
    4. Tests pass (run {{test_cmd}})
    5. No obvious incomplete work
    6. Typecheck passes

    Reply with:
    STATUS: done
    VERIFIED: What you confirmed

    Or if incomplete:
    STATUS: retry
    ISSUES:
    - What's missing or incomplete
  expected_output: >
    Verification confirmation or detailed issues requiring fixes
  agent: verifier

test_task:
  description: >
    Integration and E2E testing of the implementation.

    TASK:
    {{task}}

    REPO: {{repo}}
    BRANCH: {{branch}}
    CHANGES: {{changes}}
    BUILD_CMD: {{build_cmd}}
    TEST_CMD: {{test_cmd}}

    Your job (integration/E2E testing — unit tests were already written per-story):
    1. Run the full test suite ({{test_cmd}}) to confirm everything passes together
    2. Look for integration issues between stories
    3. If this is a UI feature, test it end-to-end
    4. Check cross-cutting concerns: error handling, edge cases across features
    5. Verify the overall feature works as a cohesive whole

    Reply with:
    STATUS: done
    RESULTS: What you tested and the outcomes

    Or if issues found:
    STATUS: retry
    FAILURES:
    - Specific test failures or bugs found
  expected_output: >
    Integration/E2E test results or identified issues
  agent: tester

pr_task:
  description: >
    Create a pull request for your changes.

    TASK:
    {{task}}

    REPO: {{repo}}
    BRANCH: {{branch}}
    CHANGES: {{changes}}
    RESULTS: {{results}}

    Create a PR with:
    - Clear title summarizing the change
    - Description explaining what and why
    - Reference to what was tested

    Use: gh pr create
  expected_output: >
    Created pull request with URL
  agent: developer
  output_file: pr_report.md

review_task:
  description: >
    Review the pull request.

    PR: {{pr}}
    TASK: {{task}}
    CHANGES: {{changes}}

    Review for:
    - Code quality and clarity
    - Potential bugs or issues
    - Test coverage
    - Follows project conventions

    Use: gh pr view, gh pr diff to read the PR.

    IMPORTANT: Post your review to the PR on GitHub using:
    - If approving: gh pr review <number> --approve --body "your review summary"
    - If requesting changes: gh pr review <number> --request-changes --body "your feedback"

    If changes needed, add comments to the PR explaining what needs to change.

    Reply with:
    STATUS: done
    DECISION: approved

    Or if changes needed:
    STATUS: retry
    DECISION: changes_requested
    FEEDBACK:
    - What needs to change
  expected_output: >
    Review decision (approved or changes requested) with feedback
  agent: reviewer
